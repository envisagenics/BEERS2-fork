###### BEERS CONFIGURATION ######
# The following file configures BEERS 2.

# The seed value initializes the random number generator
# so that runs are reproducible. Any integer works.
seed: 100

samples:
    # Specify sample-specific information
    # Samples are given identfiers, which are strings like '1' or '2'
    '1':
        # Sample one configuration
        barcodes:
            # Barcodes are used by AdapterLigationStep
            # Each sample should have unique (i5, i7) pair of barcodes
            # These get sequenced to determine which sample the read came from
            # Typical examples of these can be founda at:
            # https://support-docs.illumina.com/SHARE/AdapterSeq/Content/SHARE/AdapterSeq/TruSeq/UDIndexes.htm
            i5: AGCGCTAG
            i7: AACCGCG5
    '2':
        barcodes:
            i5: GATATCGA
            i7: TTATAAC

flowcell:
    # BEERS simulates one flowcell
    # Layout of the flowcell is defined here

    # Coordinate strategy defines how coordinates are assigned
    # Currently only 'random' is supported
    coordinate_strategy: random

    # Flowcell geometry defines the dimensions of the flowcell
    # Example is given for a typical HiSeq 2500 flowcell
    flowcell_geometry:
        # Range of the lange numbers
        min_lane: 1
        max_lane: 8
        # Range of the tile values
        max_tile: 2228
        min_tile: 1101
        # Range of the x-coordinates
        min_x: 1012
        max_x: 32816
        # Range of the y-coordinates
        min_y: 998
        max_y: 49247
    # List of lanes that samples will be written into
    # Molecules are distributed evenly across lanes
    # These must all be within [min_lane, max_lane] range
    lanes_to_use: [1, 2, 8]

molecule_maker_parameters:
    # BEERS has two different methods for generating molecules
    # Either they can be provided molecule-by-molecule in the molecule file
    # Or they can be generated on demand using CAMPAREE output sample directories
    # that contain all the information to synthesize random molecules
    # These options affect this second on-the-fly molecules.

    # The range of polyA tails to generate. Selected uniformly within this range.
    min_polyA_tail_length: 50
    max_polyA_tail_length: 250

resources:
    # Resoruces contain general-use information

    # Adapters are added to the molecules in the AdapterLigationStep
    # They are also read in the sequencing by synthesis step where they
    # are used to initiate transcription.
    # Each adapter flanks the corresponding sample barcode, which all flanks the original molecule
    # So the molecule ends up looking like (5' to 3'):
    #  (pre_i5_adapter) (i5) (post_i5_adapter) (molecule sequence (pre_i7_adapter) (i7) (post_i7_adapter)
    post_i5_adapter: ACACTCTTTCCCTACACGACGCTCTTCCGATCT
    pre_i5_adapter: AATGATACGGCGACCACCGAGATCTACAC
    pre_i7_adapter: GATCGGAAGAGCACACGTCTGAACTCCAGTCAC
    post_i7_adapter: ATCTCGTATGCCGTCTTCTGCTTG

    # Reference genome FASTA is used to generate output BAM files, which require chromosome lengths.
    # Use the same FASTA as the BEERS input (such as from CAMPAREE) was
    # generated from.
    reference_genome_fasta: CAMPAREE/resources/baby_genome.mm10/baby_genome.mm10.oneline_seqs.fa

library_prep_pipeline:
    # The library prep pipeline takes input molecules and walks them through a library prep
    # to get them ready for sequencing.
    input:
        # Input the Library Prep step, which is also the input to BEERS in general
        # The results of this will be fed to the sequencing pipeline to generate the output

        # There are TWO ways to provide input to BEERS.
        # First, we can provide molecule files, such as output by CAMPAREE
        # These specify exactly the molecules to prepare and sequence
        # Specify these by a path to a directory containing the molecule packets
        # as if generated by CAMPAREE:
        #
        # /my/directory/path:
        #   - sample1:
        #       molecule_file1.txt
        #       molecule_file2.txt
        #   - sample2:
        #       molecule_file1.txt
        #       molecule_file2.txt
        directory_path: /home/thobr/BEERS2/test_data/molecule_packets/

        # Second, we can provide CAMPAREE sample directories
        # Which instead contain the information to generate new molecules
        # based off a sample's variants, gene, isoform, and allele distributions
        from_distribution_data:
            # Specify, for each sample, what molecule data to generate (if any)
            # Samples here should correspond to the 'samples' entry above
            '1':
                # Number of packets to generate.
                # If 0, don't generate any and just use the provided molecule files
                num_packets: 1

                # Number of molecules to generate per packet.
                # Increasing this number increases the amount of work done per job.
                # Generally want to keep this under 200000 to not run out of memory.
                # If memory usage errors occur, reducing this can help.
                num_molecules_per_packet: 10000

                # Directory containing CAMPAREE output for the sample
                # This data is used to generate the resulting molecules
                sample_data_directory: /home/thobr/BEERS2/test_data/CAMPAREE_data/sample1/
            '2':
                num_molecules_per_packet: 10000
                num_packets: 1
                sample_data_directory: /home/thobr/BEERS2/test_data/CAMPAREE_data/sample2/

    steps:
        # The 'steps' list specifies all the steps that the Library Prep Pipeline
        # will run. To specify a custom step, include it here.
        # Python files with the corresponding code are looked up according to
        # the pattern {module_name}.{class_name} pattern, so that the
        # {module_name}.py file will be checked for {class_name} class

    -   step_name: polya_step.PolyAStep
        # PolyA selection step removes RNA that does not have an poly A tail
        # of sufficient length. Enriches for mRNA.
        parameters:
            # Chance per base of fragmentation prior to selection
            # Increasing this above 0 induces a 3' bias.
            # A value of 0.001 induces a reasonably high 3' bias
            breakpoint_prob_per_base: 0.0

            # Probability of retention is computed as a value between
            # min_retention_prob and max_retention_prob
            # For every base of the polyA tail beyond min_polya_tail_length
            # the probability increases linearly from min_retention_prob
            # by length_retention_prob, up to a max of max_polya_tail_length.
            max_retention_prob: 1.0
            min_retention_prob: 0.0
            min_polya_tail_length: 40
            length_retention_prob: 0.05

    -   step_name: fragment_step.FragmentStep
        # Fragmentation step breaks each molecule into pieces
        parameters:
            # Fragmentation methods are available.
            # 'uniform' fragments at each base equally and is the default
            method: uniform
            # The 'lambda' parameter is the the rate parameter for an exponential distribution
            # which determines the time it takes until a molecule to fragments.
            # Molecules which would take longer then 'runtime' to fragment, do not fragment.
            # Molecules may also fragment multiple times if lambda is high enough.
            rate: 0.005
            runtime: 1
            # Since fragmentation generates many very small fragments that will
            # be quickly lost in the following steps, we have the option to
            # drop those fragments immediately. Setting this value can significant
            # decrease runtime and memory requirements.
            min_frag_size: 20

            # If method == 'beta', then the fragmentation sites can be biased within
            # the molecule, according to a beta distribution.
            # NOTE: using 'beta' can generate unusual coverage plots since there are
            # significant edge effects around the transcript. However, it can be used
            # to give a more realistic fragment distribution.
            #
            # If using 'beta', you must also specify the following:
            #
            # The parameters for the beta distribution. Set these so that
            # A = B > 0 to bias towards fragmentation in the middle of the fragment,
            # with larger values biasing further towards the middle.
            # If A > B, then would bias towards the 5' end instead.
            # beta_A: 3.0
            # beta_B: 3.0
            #
            # And the N factor allows a non-linear fragmentation rate depending
            # upon the length of the molecule. Values >1 indicate that longer molecules
            # are more likely to fragment than smaller ones, biasing towards larger
            # fragment sizes.
            # beta_N: 2.0

    -   step_name: first_strand_synthesis_step.FirstStrandSynthesisStep
        parameters:
            perfect_priming: false
            position_probability_matrix:
                A: [0.50, 0.0, 0.40, 0.30, 0.25, 0.10]
                C: [0.20, 0.5, 0.3 , 0.25, 0.25, 0.15]
                G: [0.15, 0.1, 0.15,-0.25, 0.25, 0.20]
                T: [0.15, 0.3, 0.15, 0.20, 0.25, 0.50]
            primes_per_kb: 2

    -   step_name: second_strand_synthesis_step.SecondStrandSynthesisStep
        parameters:
            position_probability_matrix:
                C: [0.20, 0.5, 0.3 , "hello", 0.25, 0.15]
                G: [0.15, 0.1, 0.15, 0.25, 0.25, 0.20, 0.5]
                T: 6
            primes_per_kb: -2
    -   step_name: sizing_step.SizingStep
        parameters:
            max_length: 400
            min_length: 100
            select_all_end_length: 500
    -   step_name: adapter_ligation_step.AdapterLigationStep
        parameters: {}
    -   step_name: pcr_amplification_step.PCRAmplificationStep
        parameters:
            deletion_rate: 0.0001
            gc_bias_constant: 1.0
            gc_bias_linear: "hello"
            gc_bias_quadratic: -100
            insertion_rate: -3
            number_cycles: 10.5
            retention_percentage: 2.08

sequence_pipeline:
    output:
        output_fastq: true
        output_sam: true
    steps:
    -   step_name: bridge_amplification_step.BridgeAmplificationStep
        parameters:
            cycles: -10
            substitution_rate: 1.5
    -   step_name: sequence_by_synthesis_step.SequenceBySynthesisStep
        parameters:
            forward_is_5_prime: true
            paired_ends: "error"
            read_length: 100.5
            skip_rate: 1.002
