import argparse
import sys
import os
import collections
import bisect
from utils import Utils
from timeit import default_timer as timer

class UpdateAnnotationForGenome:
    """Updates a gene annotation's coordinates to account for insertions &
    deletions (indels) introduced by GenomeFilesPreparation when it creates
    variant genomes. Note, this is designed to update annotation for a single
    variant genome at a time.

    Parameters
    ----------
    genome_indel_filename : string
        Path to file containing list of indel locations generated by the
        GenomeFilesPreparation. This file has no header and contains three,
        tab-delimited colums (example):
            chr1:134937	D	2
            chr1:138813	I	1
        First column = Chromosome and coordinate of indel in the original
                       reference genome. Note, coordinate is zero-based.
        Second column = "D" if variant is a deletion, "I" if variant is an
                        insertion.
        Third column = Length in bases of indel.
    input_annot_filename : string
        Path to file containing gene/transcript annotations using coordinates
        to the original reference genome. This file should have 11, tab-delimited
        columns (example):
            chrom  strand  txStart  txEnd exonCount  exonStarts         exonEnds           transcriptID     geneID           geneSymbol  biotype
            1      +       11869    14409 3          11869,12613,13221  12227,12721,14409  ENST00000456328  ENSG00000223972  DDX11L1     pseudogene
        An annotation file with this format can be generated from a GTF file
        using the convert_gtf_to_annot_file_format() function in the Utils
        package.
    updated_annot_filename : string
        Path to the output file containing gene/transcript annotations with
        coordinates updated to match the variant genome.
    log_filename : string
        Path to the log file.

    """

    def __init__(self, genome_indel_filename, input_annot_filename,
                 updated_annot_filename, log_filename):
        """Short summary.

        Parameters
        ----------
        genome_indel_filename : string
            Full path to indel file generated by GenomeFilesPreparation.
        input_annot_filename : string
            Full path to annotation file with coordinates for reference genome.
        updated_annot_filename : string
            Full path to output annotation file with coordinates updated for
            variant genome.
        log_filename : string
            Full path to log file.

        """
        self.genome_indel_filename = genome_indel_filename
        self.input_annot_filename = input_annot_filename
        self.updated_annot_filename = updated_annot_filename
        self.log_filename = log_filename

        #Clear the output file first. Maybe we should update this so it checks
        #for an existing file first, stops and warns the user, and then the user
        #has the option of using something like a "--force" parameter to just
        #overwrite the existing file anyway?
        try:
            os.remove(self.updated_annot_filename)
        except OSError:
            pass

    def update_annotation(self):
        """Main work-horse function that generates the updated annotation.
        """
        #TODO: check input annotation and variant files are sorted by chr in the same order

        with open(self.genome_indel_filename, 'r') as genome_indel_file, \
                open(self.input_annot_filename, 'r') as input_annot_file, \
                open(self.updated_annot_filename, 'w') as updated_annot_file, \
                open(self.log_filename, 'w') as log_file:

            #Skip header in annotation file and load first annotated feature
            annot_feature = input_annot_file.readline()

            current_chrom = ""

            for annot_feature in input_annot_file:

                annot_feature = annot_feature.rstrip('\n')
                line_data = annot_feature.split('\t')

                if current_chrom != line_data[0]:
                    log_file.write("Processing variants and annotated features from chrom ", line_data[0])
                    current_chrom_variants = UpdateAnnotationForGenome._read_chr_from_variant_file(genome_indel_file, current_chrom)
                    #Since code below will be performing many lookups and index-
                    #based references to the values and keys in current_chrom_variants,
                    #it will likely be more efficient to create a list of values
                    #and a list of keys from current_chrom_variants once, rather
                    #than re-creating them each time the code needs to access a
                    #key or value by ordered index.
                    current_chrom_variant_coords = list(current_chrom_variants.keys())
                    current_chrom_variant_offsets = list(current_chrom_variants.items())
                    current_chrom = line_data[0]

                #Current chromosome contains at least one variant
                if len(current_chrom_variant_coords) > 0:

                    tx_start = int(line_data[2])
                    tx_end = int(line_data[3])
                    #exon_count = int(line_data[4])
                    exon_starts = [int(coord) for coord in line_data[5].split(',')]
                    exon_ends = [int(coord) for coord in line_data[6].split(',')]

                    #bisect_right() finds the index at which to insert the given
                    #coordinate in sorted order. Since I'm looking for the
                    #closest coordinate <= the given coordinate, subtract 1 from
                    #the result of bisect_right() to get the correct index.
                    tx_start_offset_index = bisect.bisect_right(current_chrom_variant_coords, tx_start) - 1
                    tx_end_offset_index = bisect.bisect_right(current_chrom_variant_coords, tx_end) - 1

                    #No new variants between the start and stop coordinates, so
                    #apply the same offset to all coordinates in the current
                    #feature.
                    if tx_start_offset_index == tx_end_offset_index:
                        offset = current_chrom_variant_offsets[tx_start_offset_index]
                        updated_tx_start = tx_start + offset
                        updated_tx_end = tx_end + offset
                        updated_exon_starts = [coord+offset for coord in exon_starts]
                        updated_exon_ends = [coord+offset for coord in exon_ends]
                    else:
                        updated_tx_start = tx_start + current_chrom_variant_offsets[tx_start_offset_index]
                        updated_tx_end = tx_end + current_chrom_variant_offsets[tx_end_offset_index]

                        #Update lists of exon starts/ends with correct offsets
                        updated_exon_starts = []
                        updated_exon_ends = []
                        for coord in exon_ends:
                            ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                            updated_exon_coord = coord + current_chrom_variant_offsets[ex_coord_offset_index]
                            updated_exon_starts.append(updated_exon_coord)
                        for coord in exon_starts:
                            ex_coord_offset_index = bisect.bisect_right(current_chrom_variant_coords, coord) - 1
                            updated_exon_coord = coord + current_chrom_variant_offsets[ex_coord_offset_index]
                            updated_exon_ends.append(updated_exon_coord)

                    #Format updated annotation data and output
                    updated_annot_file.write(
                        Utils.annot_output_format.format(
                            chrom=line_data[0],
                            strand=line_data[1],
                            txStart=updated_tx_start,
                            txEnd=updated_tx_end,
                            exonCount=line_data[4],
                            exonStarts=','.join(updated_exon_starts),
                            exonEnds=','.join(updated_exon_ends),
                            transcriptID=line_data[7],
                            geneID=line_data[8],
                            geneSymbol=line_data[9],
                            biotype=line_data[10]
                        )
                    )

                #No variants in the current chromosome, so no need to update
                #feature coordinates.
                else:
                    updated_annot_file.write(f"{annot_feature}\n")


    @staticmethod
    def _read_chr_from_variant_file(variant_file, chrom):
        """Read all variants in the indel file from the given chromosome,
        calculate rolling offset at each variant position, and return result in
        an ordered dictionary.

        Note, upon finding the next chromosome after the given one, this method
        will rewind the variant_file iterator one line. This way the next time
        the iterator is accessed, it will return the first line from the next
        chromosome, rather than skipping it (since it would already have been
        iterated over when identifying the start of the next chromosome).

        Parameters
        ----------
        variant_file : file
            File iterator pointing to a genome_indel_filename.
        chrom : string
            Chromosome name.

        Returns
        -------
        OrderedDict
            Collection of variant coordinates and corresponding rolling offsets
            at each position for the given chromosome.
            Key = chromosomal coordinate of variant position
            Value = rolling offest at variant position
            If the given chromosome name is not present in the remainder of the
            variant file, then this function returns an empty OrderedDict
            object.

        """
        variant_offsets = collections.OrderedDict()
        rolling_offset = 0

        #Need to keep track of file position as I read through. Then I can jump
        #back one line once I'm done reading variant positions from the current
        #chromosome to make sure I don't lose the first line of the next
        #chromosome.

        #The logic of the code below is built on the assumption that any
        #chromosomes contained in the variant file between its current position
        #and the location of the desired chromosome can safely be skipped. As
        #it's coded up below, the variant_file iterator will be left at the
        #first entry after all variants from the desired chromosome, or it will
        #reset its position if no instances of the desired chromosome are found.
        #Any entries prior to the desired chromosome (if found) are skipped and
        #lost to future analyses. This will not pose a problem if the variant
        #file is queried in the same order that it is sorted (i.e. after a
        #chromosome is skipped/processed, it will not be queried later).

        #Track starting position in the variant file. If the entire file is
        #searched before the desired chrom is found, reset the file iterator
        #to this start position, so no chromosomes are skipped in future
        #searches.
        variant_file_start_position = variant_file.tell()

        #Track current position in the variant file, so I can return to the
        #previous line if needed.
        prev_line_file_position = variant_file.tell()

        chrom_found = False
        for line in variant_file:
            line_data = line.split('\t')
            indel_chrom, indel_position = line_data[0].split(':')
            if indel_chrom == chrom:
                chrom_found = True
                break
            else:
                prev_line_file_position = variant_file.tell()

        #TODO: Once we've implemented generic utility functions for making
        #      ordered comparisons of chromosome names, I can change the code
        #      above to break when it finds the first chromosome >= the desired
        #      one. This will prevent the above loop from running until the end
        #      of the variant file if the desired chromosome is not present in
        #      the variant file.

        if not chrom_found:
            #Rewind to position variant file started at
            variant_file.seek(variant_file_start_position)
        else:
            #Backup position of pointer in variant_file so the first variant
            #on the desired chromosome will be re-read in the loop below.
            #Otherwise, the loop would skip straight to the second entry for
            #the desired chromosome.
            variant_file.seek(prev_line_file_position)

            for line in variant_file:

                indel_chrom, indel_position = line_data[0].split(':')
                indel_position = int(indel_position)
                indel_type = line_data[1]
                indel_offset = int(line_data[2])

                #Entries for the next chromosome found (i.e. done extracting
                #variants from desired chromosome)
                if indel_chrom != chrom:
                    #Backup position of pointer in variant_file to avoid skipping
                    #first variant in the next chromosome, the next time the
                    #iterator is accessed. Otherwise, any code to processed the
                    #next chromosome would skip straight to the second entry.
                    variant_file.seek(prev_line_file_position)
                    break

                #If variant is a deletion, make offset negative so it subtracts
                #from the rolling offset.
                if indel_type == 'D':
                    indel_offset *= -1

                rolling_offset += indel_offset
                variant_offsets[indel_position] = rolling_offset

        return variant_offsets

    @staticmethod
    def main():
        """Entry point into script.

        Parses arguments, gathers input and output filenames, and calls scripts
        that perform the actual operation.

        Returns
        -------
        type
            Description of returned object.

        """
        parser = argparse.ArgumentParser(description='Update annotation file for variant genome')
        parser.add_argument('-g', '--genome_indel_filename')
        parser.add_argument('-i', '--input_annot_filename')
        parser.add_argument('-o', '--updated_annot_filename')
        parser.add_argument('-l', '--log_filename')

        args = parser.parse_args()
        updated_annotation = UpdateAnnotationForGenome(args.genome_indel_filename,
                                                        args.input_annot_filename,
                                                        args.updated_annot_filename,
                                                        args.log_filename)
        start = timer()
        updated_annotation.update_annotation()
        end = timer()
        print(f"Updated annotation: {end - start}")


    if __name__ == '__main__':
        sys.exit(UpdateAnnotationForGenome.main())



"""Things I'll need to consider with this program:
    1) Transcripts/genes that overlap the same coordinates. I'll need to repeat
       the process for each one, which could involve re-processing the same set
       of indels multiple times. I might want to read all indels for a given
       chromosome into a data structure and then process each of the transcripts
       from the same chromosome. This way maybe I can just lookup the set of
       indels I'll need for a given transcript?
    2) Following from 1), I'll need to handle annotations from chromosomes that
       don't contain any variants (i.e. they'd be absent from the indel file).
    3) I'll need to track rolling coordinate changes as I go. It won't be enough
       just to increment/decrement each feature coordinate by each indel length.
       Maybe the overall architecture of the program should be it processes the
       indels by determining the updated coordinate at the location of each indel.
       Then, as it's processing a gene annotation, it just looks up the current
       offset for the closest indel <= each of its coordinates. For example, if
       at reference position chr1:12345, I know the cummulative offset is +15,
       because of all the indels that have occurred at and before that position,
       and I'm processing feature coordinate at chr:12350, I just look up the
       rolling offset calculated at the closest variant position less than the
       feature coordinate (the one at chr1:12345), and add the rolling offset.
    4) Here are some pythonic solutions to the fast lookup table problem:
       https://stackoverflow.com/questions/7934547/python-find-closest-key-in-a-dictionary-from-the-given-input-key
       See second and third answers. Note, I don't think I can count on having
       Python >= 3.7 (which orders dictionary keys based on the order they are)
       input), so I'm going to need to use another datastructure (there are some
       suggestisons in the stackoverflow link above).
            -If I use the bisect function, I might be able to shorten the search
             space by dropping a subset of variants that have already been
             processed. This only really matters if there's a performance hit
             from all of the continued lookups.
    5) Following from 4, if I can find a quick/efficient way of finding the
       closest variants to the start and end coordinate for a given feature, is
       there a way to quickly grab all of the entries bewteen these two extremes?
       Looking at the bisect and OrderedDict example in the stackoverflow link,
       I think bisect just returns an index, rather than a value, so I can just
       grab a list slice using from the OrderedDict, once I have the first and
       last variant indexes I'll need.
    6) Another thought: If I use a properly-sorted GTF file, this may all be a
       non-issue. Then again, GTF features still have a start and stop, so I'd
       still need to be grabbing multiple coordinates.
    7) Potential update to OrderedDict that might be faster for doing a lot of
       list conversions (https://pypi.org/project/ruamel.ordereddict/). Also,
       this page provides a lot of useful info (especially the comments below
       the accepted answer). Also, Quantum7's answer gives a great overview of
       everything and suggests I might be okay sticking to an OrderedDict.

"""
