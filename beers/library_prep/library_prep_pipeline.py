import importlib
import time
import os
import resource
import json
import math

import numpy as np

from beers_utils.constants import CONSTANTS
from beers_utils.molecule import Molecule
from beers_utils.molecule_packet import MoleculePacket
from beers.utilities.general_utils import GeneralUtils


class LibraryPrepPipeline:
    """
    The class runs all the steps in the library_prep pipeline as described ans wired together in the configuration
    file.  The point of entry into this class is the static method main().
    """

    stage_name = "library_prep_pipeline"
    pipeline_log_subdirectory_name = "Pipeline"
    package = "beers.library_prep"

    def __init__(self, configuration, output_directory_path, directory_structure, molecule_packet):
        """
        Many initialization steps here include identifying the log and data directories and subdirectories so
        that data and log files generated are placed in the correct locations.  Note that the directory structure
        has already been created by the controller.  The steps described in the configuration dictionary are
        instantiated and those instantialed steps are added to a list to further use.
        :param configuration:  dictionary of the configuration data relevant to this pipeline stage.
        :param output_directory_path: top level directory for data and logs generated by this pipeline stage
        :param directory_structure: instructions for navigating the subdirectories under the output directory
        :param molecule_packet: the molecule packet to run through this pipeline stage
        """
        self.molecule_packet = molecule_packet
        log_directory_path = os.path.join(output_directory_path, CONSTANTS.LOG_DIRECTORY_NAME)
        data_directory_path = os.path.join(output_directory_path, CONSTANTS.DATA_DIRECTORY_NAME)
        subdirectory_list = \
            GeneralUtils.get_output_subdirectories(self.molecule_packet.molecule_packet_id, directory_structure)
        data_subdirectory_path = os.path.join(data_directory_path, *subdirectory_list)
        self.original_ids = set(str(m.molecule_id) for m in self.molecule_packet.molecules)
        self.print_summary(self.molecule_packet.molecules)
        self.log_file_path = os.path.join(log_directory_path,
                                          LibraryPrepPipeline.pipeline_log_subdirectory_name,
                                          *subdirectory_list,
                                          f"{LibraryPrepPipeline.stage_name}_"
                                          f"molecule_pkt{self.molecule_packet.molecule_packet_id}.log")
        self.steps = []
        for step in configuration['steps']:
            module_name, step_name = step["step_name"].rsplit(".")
            step_log_filename = f"{step_name}_molecule_pkt{self.molecule_packet.molecule_packet_id}.log"
            step_log_file_path = os.path.join(log_directory_path, step_name, *subdirectory_list, step_log_filename)
            parameters = step["parameters"]
            module = importlib.import_module(f'.{module_name}', package=LibraryPrepPipeline.package)
            step_class = getattr(module, step_name)
            self.steps.append(step_class(step_log_file_path, parameters))
        results_filename = f"{LibraryPrepPipeline.stage_name}_" \
                           f"result_molecule_pkt{self.molecule_packet.molecule_packet_id}.txt"
        self.results_file_path = os.path.join(data_subdirectory_path, results_filename)

    @staticmethod
    def validate(configuration):
        """
        Static method to run each step validate process to identify errant parameters.  If any errors are found,
        a validation exception is raised.
        """
        #if not all([molecule.validate() for molecule in self.molecule_packet.molecules]):
        #    raise BeersLibraryPrepValidationException("Validation error in molecule packet: see stderr for details.")
        steps = []
        for step in configuration['steps']:
            module_name, step_name = step["step_name"].rsplit(".")
            parameters = step["parameters"]
            module = importlib.import_module(f'.{module_name}', package=LibraryPrepPipeline.package)
            step_class = getattr(module, step_name)
            steps.append(step_class(None, parameters))
        if not all([step.validate() for step in steps]
                   + [LibraryPrepPipeline.validate_flowcell_retention(configuration)]):
            raise BeersLibraryPrepValidationException("Validation error in step: see stderr for details.")

    @staticmethod
    def validate_flowcell_retention(configuration):
        valid = True
        msg = ""
        if 'flowcell_retention_percentage' not in configuration:
            valid = False
            msg += f"A flowcell retention percentage must be specified."
        if configuration['flowcell_retention_percentage'] <= 0 or configuration['flowcell_retention_percentage'] >= 100:
            valid = False
            msg += f"The flowcell retention percentage, {configuration['flowcell_retention_percentage']}," \
                   f" must be between 0 and 100 exclusive."
        return valid

    def execute(self, flowcell_retention):
        """
        Opens the pipeline log for writing and serially runs the execute method of each step object found in the
        step list generated when this pipeline stage was initialized.  The final product (a modified molecule
        packet) is serialized into a data file.  Note that loss due to flowcell loading is incorporated into this
        packet to avoid creating overly large files.
        """
        with open(self.log_file_path, 'w') as log_file:
            self.log_sample(log_file)
            pipeline_start = time.time()
            molecule_packet = self.molecule_packet
            for step in self.steps:
                step_name = step.__class__.name if hasattr(step.__class__, 'name') else step.__class__.__name__
                step_start = time.time()
                molecule_packet = step.execute(molecule_packet)
                elapsed_time = time.time() - step_start

                self.print_summary(molecule_packet.molecules, elapsed_time)

                # Saves the state of the random number generator after completion of each step in the event that
                # we may need to do to partial repeat of the library_prep pipeline stage (although exactly how
                # to implement such a partial repeat hasn't been given serious consideration as yet).
                random_state = np.random.get_state()
                log_file.write(f"# random state following {step_name} is {random_state}\n")
                print(f"{step_name} complete - process RAM currently at"
                      f" {resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1E6} GB")

            pipeline_elapsed_time = time.time() - pipeline_start
            print(f"Finished {LibraryPrepPipeline.stage_name} in {pipeline_elapsed_time:.1f} seconds")

        # Need to use flowcell retention rate here to avoid storing massive files.
        number_samples_to_draw = math.floor(flowcell_retention * len(molecule_packet.molecules))
        retained_molecules = np.random.choice(molecule_packet.molecules, size=number_samples_to_draw, replace=False)
        molecule_packet.molecules = retained_molecules

        # Write final sample to a gzip file for inspection
        molecule_packet.serialize(self.results_file_path)
        print(f"Output final sample to {self.results_file_path}")

    def log_sample(self, log_file):
        """
        Logs the molecules the pipeline stage begins with.  We need to
        consider gzipping.
        :param log_file: The handle to the log file.
        """
        log_file.write(Molecule.header)
        for molecule in self.molecule_packet.molecules:
            log_file.write(molecule.log_entry())

    def print_summary(self, sample, elapsed_time=None):
        """
        Output a summary of the sample (number of molecules, time taken, etc.)
        :param sample:
        :param elapsed_time:
        """
        if elapsed_time is not None:
            print(f"Step took {elapsed_time:.3} seconds")

        print(f"Sample has {len(sample)} molecules")
        parent_ids = set(str(m.molecule_id).split(".")[0] for m in sample)
        percent_original_represented = len(self.original_ids.intersection(parent_ids))/len(self.original_ids)
        print(f"Percent of the original ids that are still represented: {percent_original_represented:0.2%}")

        size_bin_cutoffs = [100, 500, 1000]
        size_counts = [0]*(len(size_bin_cutoffs)+1)
        for molecule in sample:
            size_counts[np.searchsorted(size_bin_cutoffs, len(molecule))] += 1
        print(f"Counts of molecules in size ranges:")
        for i in range(len(size_bin_cutoffs)):
            print(f" <={size_bin_cutoffs[i]}: {size_counts[i]}")
        print(f">{size_bin_cutoffs[-1]}: {size_counts[-1]}")

    @staticmethod
    def main(seed, configuration, input_directory_path, output_directory_path,
             directory_structure, molecule_packet_filename):
        """
        This method would be called by a command line script in the bin directory.  It sets a random seed, loads a
        directory containing the relevant parts of the user's configuration file, unmarshalls a molecule packet from
        the provided molecule packet filename, initializes and validates the library prep pipeline stage and then
        executes it for the molecule packet
        :param seed: value to use as the seed for the random number generator
        :param configuration: the json string containing the configration data specific to the library prep pipeline
        :param input_directory_path: path to directory containing the molecule packet file
        :param output_directory_path: top level output directory path for this pipeline stage
        :param directory_structure: instructions for creating the scaffolding needed to house the pipeline data and logs
        :param molecule_packet_filename: the file from which to unmarshall the molecule packet
        """
        np.random.seed(int(seed))
        configuration = json.loads(configuration)
        molecule_packet = MoleculePacket.get_serialized_molecule_packet(input_directory_path, molecule_packet_filename)
        library_prep_pipeline = LibraryPrepPipeline(configuration, output_directory_path, directory_structure,
                                                    molecule_packet)
        library_prep_pipeline.execute(configuration['flowcell_retention_percentage']/100)


class BeersLibraryPrepValidationException(Exception):
    pass
